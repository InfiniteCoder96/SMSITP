'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _fsExtra = require('fs-extra');

var _fsExtra2 = _interopRequireDefault(_fsExtra);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _replace2 = require('./replace');

var _replace3 = _interopRequireDefault(_replace2);

var _minimatch = require('minimatch');

var _minimatch2 = _interopRequireDefault(_minimatch);

var _globParent = require('glob-parent');

var _globParent2 = _interopRequireDefault(_globParent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var File = function () {
  function File() {
    _classCallCheck(this, File);
  }

  _createClass(File, [{
    key: 'locate',
    value: function locate(filepath) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (_path2.default.isAbsolute(filepath)) {
        return filepath;
      }
      options = Object.assign({
        cwd: process.cwd()
      }, options);

      return _path2.default.join(options.cwd, filepath);
    }
  }, {
    key: 'exists',
    value: function exists(filename, options) {
      try {
        return _fsExtra2.default.statSync(this.locate(filename, options)).isFile();
      } catch (e) {
        if (e.code === 'ENOENT') {
          return false;
        }

        throw e;
      }
    }
  }, {
    key: 'isDirectory',
    value: function isDirectory(directory, options) {
      try {
        return _fsExtra2.default.statSync(this.locate(directory, options)).isDirectory();
      } catch (e) {
        if (e.code === 'ENOENT') {
          return false;
        }

        throw e;
      }
    }
  }, {
    key: 'remove',
    value: function remove(filepath, options) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _fsExtra2.default.remove(_this.locate(filepath, options), function (err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
  }, {
    key: 'read',
    value: function read(filename) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options = Object.assign({
        encoding: 'utf-8'
      }, options);

      return new Promise(function (resolve, reject) {
        _fsExtra2.default.readFile(_this2.locate(filename, options), function (err, content) {
          if (err) {
            reject(err);
          } else {
            resolve(content);
          }
        });
      });
    }
  }, {
    key: 'copy',
    value: function copy(src, dest, options) {
      var _this3 = this;

      /*eslint no-unneeded-ternary: "off"*/
      options = Object.assign({
        clobber: options.override ? true : false,
        preserveTimestamps: false
      }, options);

      delete options.override;

      return new Promise(function (resolve, reject) {
        _fsExtra2.default.copy(_this3.locate(src, options), _this3.locate(dest, options), options, function (err) {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
  }, {
    key: 'replace',
    value: function replace(src, dest, rules, options) {
      var _this4 = this;

      options = Object.assign({
        encoding: 'utf-8',
        override: true
      }, options);

      return this.read(src, options).then(function (content) {
        content = (0, _replace3.default)(content.toString(options.encoding), rules);

        return _this4.write(dest, content, options);
      });
    }
  }, {
    key: 'write',
    value: function write(src, content, options) {
      var _this5 = this;

      options = Object.assign({
        encoding: 'utf-8',
        override: true
      }, options);

      var override = options.override;
      delete options.override;

      return new Promise(function (resolve, reject) {
        var filepath = _this5.locate(src, options);
        _fsExtra2.default.ensureFile(filepath, function (err) {
          if (err) {
            reject(err);
          }

          if (override) {
            _this5.remove(filepath, options).then(function () {
              _fsExtra2.default.writeFile(filepath, content, options || {}, function (err) {
                if (err) {
                  reject(err);
                } else {
                  resolve();
                }
              });
            }).catch(reject);
          } else {
            _fsExtra2.default.writeFile(filepath, content, options || {}, function (err) {
              if (err) {
                reject(err);
              } else {
                resolve();
              }
            });
          }
        });
      });
    }
  }, {
    key: 'readJSON',
    value: function readJSON(filepath, defaults, options) {
      options = Object.assign({
        encoding: 'utf-8'
      }, options);

      filepath = this.locate(filepath, options);

      if (this.exists(filepath)) {
        try {
          return JSON.parse(_fsExtra2.default.readFileSync(filepath));
        } catch (error) {
          throw new Error('Could not parse JSON in file: ' + filepath + '. Detail: ' + error.message);
        }
      } else {
        return defaults;
      }
    }
  }, {
    key: 'cleanFiles',
    value: function cleanFiles(files, options) {
      var _this6 = this;

      options = Object.assign({
        verbose: false,
        log: console.log,
        ignoreError: true
      }, options);

      var log = options.verbose ? options.log : function () {};

      return new Promise(function (resolve, reject) {
        if (!Array.isArray(files)) {
          files = [files];
        }
        var opts = {};
        if (options.cwd) {
          opts.cwd = options.cwd;
        }

        var all = files.map(function (target) {
          return _this6.remove(target, opts).then(log(_chalk2.default.red('Removing: ') + target)).catch(function (err) {
            if (options.ignoreError === false) {
              reject('Cannot clean \'' + target + '\': ' + err.code);
            }
          });
        });

        Promise.all(all).then(resolve).catch(reject);
      });
    }
  }, {
    key: 'copyFiles',
    value: function copyFiles(files, options) {
      var _this7 = this;

      options = Object.assign({
        verbose: false,
        override: true,
        log: console.log,
        replaces: {},
        processes: {}
      }, options);

      var log = options.verbose ? options.log : function () {};

      return new Promise(function (resolve, reject) {
        if (!Array.isArray(files)) {
          files = [files];
        }

        var opts = {
          override: options.override
        };
        if (options.cwd) {
          opts.cwd = options.cwd;
        }

        var all = files.map(function (target) {
          var promise = null;
          var replaces = {};

          if (options.replaces) {
            for (var glob in options.replaces) {
              if ((0, _minimatch2.default)(target.dest, glob, { matchBase: true })) {
                Object.assign(replaces, options.replaces[glob]);
              }
            }
          }

          if (Object.keys(replaces).length === 0) {
            promise = _this7.copy(target.src, target.dest, opts);
          } else {
            promise = _this7.replace(target.src, target.dest, replaces, opts);
          }

          if (options.processes) {
            (function () {
              var processes = [];

              for (var _glob in options.processes) {
                if ((0, _minimatch2.default)(target.dest, _glob, { matchBase: true })) {
                  if (Array.isArray(options.processes[_glob])) {
                    processes = processes.concat(options.processes[_glob]);
                  } else {
                    processes.push(options.processes[_glob]);
                  }
                }
              }

              if (processes.length !== 0) {

                promise = promise.then(function () {
                  return _this7.read(target.dest, opts).then(function (content) {
                    content = content.toString(options.encoding);
                    processes.forEach(function (process) {
                      if (typeof process === 'string') {
                        eval("process = " + process);
                      }

                      content = process(content, target.dest);
                    });
                    return _this7.write(target.dest, content, options);
                  });
                });
              }
            })();
          }

          return promise.then(log(_chalk2.default.green('Copying: ') + target.src + _chalk2.default.cyan(' -> ') + target.dest)).catch(function (err) {
            reject('Cannot copy ' + target.src + '\'\' to \'' + target.dest + '\': ' + err.message);
          });
        });

        Promise.all(all).then(resolve).catch(reject);
      });
    }
  }, {
    key: 'getFilenameWithIndex',
    value: function getFilenameWithIndex(filepath, index) {
      var parsed = _path2.default.parse(filepath);

      return _path2.default.join(parsed.root, parsed.dir, parsed.name + '-' + index + parsed.ext);
    }
  }, {
    key: 'getRelativeFromGlobs',
    value: function getRelativeFromGlobs(filepath, globs) {
      var glob = this.matchGlob(filepath, globs);

      if (glob) {
        return _path2.default.relative((0, _globParent2.default)(glob), filepath);
      }

      return _path2.default.basename(filepath);
    }
  }, {
    key: 'matchGlob',
    value: function matchGlob(filepath, globs) {
      if (!Array.isArray(globs)) {
        globs = [globs];
      }

      for (var i in globs) {
        if ((0, _minimatch2.default)(filepath, globs[i])) {
          return globs[i];
        }
      }

      return false;
    }
  }]);

  return File;
}();

var file = new File();

exports.default = file;
module.exports = exports['default'];