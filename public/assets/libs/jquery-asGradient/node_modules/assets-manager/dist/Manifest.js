'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _file = require('./file');

var _file2 = _interopRequireDefault(_file);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _Package = require('./Package');

var _Package2 = _interopRequireDefault(_Package);

var _isPlainObject = require('is-plain-object');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _configure = require('./configure');

var _configure2 = _interopRequireDefault(_configure);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _types = require('./types');

var _types2 = _interopRequireDefault(_types);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _rename = require('./rename');

var _rename2 = _interopRequireDefault(_rename);

var _deepExtend = require('deep-extend');

var _deepExtend2 = _interopRequireDefault(_deepExtend);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _es6Template = require('es6-template');

var _es6Template2 = _interopRequireDefault(_es6Template);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Manifest
 *
 * @class
 */
var Manifest = function () {
  function Manifest(filepath) {
    var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Manifest);

    if ((0, _isPlainObject2.default)(filepath)) {
      this.filepath = '.';
      this.data = filepath;
    } else {
      if (typeof filepath === 'undefined') {
        this.filepath = './manifest.json';
      } else {
        this.filepath = filepath;
      }

      (0, _assert2.default)(_file2.default.exists(this.filepath), 'Manifest file is not exists');

      this.data = _file2.default.readJSON(this.filepath);
    }

    this.data = (0, _deepExtend2.default)(this.data, override);

    this.prepareConfigures();
    this.prepareRegistries();
    this.preparePackages();
    this.prepareDests();
    this.preparePaths();
  }

  _createClass(Manifest, [{
    key: 'forEachPackage',
    value: function forEachPackage(type, callback) {
      if (typeof type === 'function' && typeof callback === 'undefined') {
        callback = type;
        type = null;
      }
      var packages = this.packages;

      var self = this;

      Object.keys(packages).forEach(function (key) {
        var pkg = packages[key];

        if (type) {
          var files = [];

          files = pkg.getFilesByType(type);

          callback.call(self, pkg, files);
        } else {
          callback.call(self, pkg);
        }
      });
    }
  }, {
    key: 'getPackagesFiles',
    value: function getPackagesFiles(type, options) {
      if ((0, _isPlainObject2.default)(type) && typeof options === 'undefined') {
        options = type;
        type = null;
      }

      var files = void 0;
      if (type) {
        files = [];

        for (var pkg in this.installedPackages) {
          files = files.concat(this.installedPackages[pkg].getFilesByType(type, options));
        }
      } else {
        files = {};

        for (var _pkg in this.installedPackages) {
          var typedFiles = this.installedPackages[_pkg].getTypedFiles(options);
          for (var t in typedFiles) {
            if (t in files) {
              files[t] = files[t].concat(typedFiles[t]);
            } else {
              files[t] = typedFiles[t];
            }
          }
        }
      }

      return files;
    }
  }, {
    key: 'getPackageFileMapping',
    value: function getPackageFileMapping(name) {
      var pkg = this.getPackage(name);
      if (pkg === null) {
        throw new Error('Package ' + name + ' is not exists.');
      }

      if (!pkg.isInstalled()) {
        throw new Error('Package ' + pkg.options.registry + ':' + name + ' is not installed. Please ' + pkg.getInstallCmd() + '.');
      }

      var dests = Object.assign(this.dests, pkg.getDests());
      var paths = Object.assign(this.paths, pkg.getPaths());
      var typedFiles = pkg.getTypedFiles();
      var files = [];
      var renameRules = Object.assign(this.getConfigure('renames'), pkg.options.renames);

      var exists = {};

      var _loop = function _loop(type) {
        if (type in dests) {
          typedFiles[type].forEach(function (filepath) {
            // ${dest}/${type}/${package}/${file}
            var vars = {
              dest: pkg.options.dest,
              package: '',
              type: '',
              file: _path2.default.basename(filepath)
            };

            var dest = void 0;

            if (!pkg.options.flatten) {
              vars.file = _file2.default.getRelativeFromGlobs(filepath, pkg.getGlobByType(type));
            }

            if (renameRules) {
              vars.file = (0, _rename2.default)(vars.file, renameRules);
            }

            if (!pkg.options.flattenPackages) {
              if (pkg.options.package) {
                vars.package = pkg.options.package;
              } else {
                vars.package = pkg.name;
              }
            }

            if (!pkg.options.flattenTypes) {
              vars.type = dests[type];
            }

            if (type in paths) {
              dest = (0, _es6Template2.default)(paths[type], vars);
            } else {
              dest = (0, _es6Template2.default)(pkg.options.path, vars);
            }

            if (typeof exists[dest] === 'undefined') {
              exists[dest] = 0;
            } else {
              exists[dest]++;
              dest = _file2.default.getFilenameWithIndex(dest, exists[dest]);
            }

            files.push({
              src: _path2.default.join(pkg.path, filepath),
              dest: dest
            });
          });
        }
      };

      for (var type in typedFiles) {
        _loop(type);
      }

      return files;
    }
  }, {
    key: 'copyPackages',
    value: function copyPackages() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options = Object.assign({
        ignoreError: this.getConfigure('ignoreError')
      }, options);

      var promises = [];
      for (var pkg in this.packages) {
        promises.push(this.copyPackage(pkg, options));
      }
      return Promise.all(promises);
    }
  }, {
    key: 'copyPackage',
    value: function copyPackage(name) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options = Object.assign({
        verbose: this.getConfigure('verbose'),
        override: this.getConfigure('override'),
        ignoreError: false,
        log: console.log
      }, options);

      var log = options.verbose ? options.log : function () {};

      return new Promise(function (resolve, reject) {
        if (options.verbose) {
          log(_chalk2.default.blue('Copy Package ') + name + ':');
        }

        if (!_this.hasPackage(name)) {
          if (options.ignoreError) {
            log(_chalk2.default.red('Error: Package ' + name + ' is not exists.'));
            return resolve();
          }
          return reject(new Error('Package ' + name + ' is not exists.'));
        }

        var pkg = _this.getPackage(name);

        if (!pkg.isInstalled()) {
          if (options.ignoreError) {
            log(_chalk2.default.red('Error: Package ' + pkg.options.registry + ':' + name + ' is not installed.') + (' Please ' + pkg.getInstallCmd() + '.'));
            return resolve();
          }
          return reject(new Error('Package ' + pkg.options.registry + ':' + name + ' is not installed. Please ' + pkg.getInstallCmd() + '.'));
        }

        var files = void 0;
        try {
          files = _this.getPackageFileMapping(name);
        } catch (error) {
          reject(error);
        }

        _file2.default.copyFiles(files, Object.assign({
          cwd: _configure2.default.get('cwd'),
          replaces: Object.assign(_this.getConfigure('replaces'), pkg.options.replaces),
          processes: Object.assign(_this.getConfigure('processes'), pkg.options.processes)
        }, options)).then(resolve).catch(reject);
      });
    }
  }, {
    key: 'cleanPackages',
    value: function cleanPackages() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options = Object.assign({
        ignoreError: this.getConfigure('ignoreError')
      }, options);

      var promises = [];
      for (var pkg in this.packages) {
        promises.push(this.cleanPackage(pkg, options));
      }
      return Promise.all(promises);
    }
  }, {
    key: 'cleanPackage',
    value: function cleanPackage(name) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options = Object.assign({
        verbose: this.getConfigure('verbose'),
        log: console.log,
        ignoreError: false
      }, options);

      var log = options.verbose ? options.log : function () {};

      return new Promise(function (resolve, reject) {
        if (options.verbose) {
          log(_chalk2.default.magenta('Clean Package ') + name + ':');
        }

        if (!_this2.hasPackage(name)) {
          if (options.ignoreError) {
            log(_chalk2.default.red('Error: Package ' + name + ' is not exists.'));
            return resolve();
          }
          return reject(new Error('Package ' + name + ' is not exists.'));
        }

        var pkg = _this2.getPackage(name);

        if (!pkg.isInstalled()) {
          if (options.ignoreError) {
            log(_chalk2.default.red('Error: Package ' + pkg.options.registry + ':' + name + ' is not installed.') + (' Please ' + pkg.getInstallCmd() + '.'));
            return resolve();
          }
          return reject(new Error('Package ' + pkg.options.registry + ':' + name + ' is not installed. Please ' + pkg.getInstallCmd() + '.'));
        }

        var files = void 0;
        try {
          files = _this2.getPackageFileMapping(name);
        } catch (error) {
          reject(error);
        }

        var destFiles = [];

        files.forEach(function (file) {
          destFiles.push(file.dest);
        });

        _file2.default.cleanFiles(destFiles, Object.assign({
          cwd: _configure2.default.get('cwd')
        }, options)).then(resolve).catch(reject);
      });
    }
  }, {
    key: 'getPackage',
    value: function getPackage(name) {
      if (name in this.packages) {
        return this.packages[name];
      }
      return null;
    }
  }, {
    key: 'hasPackage',
    value: function hasPackage(name) {
      if (name in this.packages) {
        return true;
      }
      return false;
    }
  }, {
    key: 'getPackagesInfo',
    value: function getPackagesInfo() {
      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['name', 'version', 'license'];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var info = {};

      options = Object.assign({
        fillNull: false
      }, options);

      var packageInfo = void 0;
      var obj = void 0;

      for (var pkg in this.installedPackages) {
        packageInfo = this.installedPackages[pkg].getInfo();
        obj = {};

        /*eslint no-loop-func: "off"*/
        keys.forEach(function (key) {
          if (key in packageInfo) {
            obj[key] = packageInfo[key];
          } else if (options.fillNull) {
            obj[key] = null;
          }
        });
        info[pkg] = obj;
      }

      return info;
    }
  }, {
    key: 'setConfigure',
    value: function setConfigure(key, value, def) {
      if (typeof value === 'undefined') {
        _configure2.default.set(key, def);
      } else {
        _configure2.default.set(key, value);
      }
    }
  }, {
    key: 'getConfigure',
    value: function getConfigure(key) {
      return _configure2.default.get(key);
    }
  }, {
    key: 'prepareConfigures',
    value: function prepareConfigures() {
      this.setConfigure('verbose', this.data.verbose, true);
      this.setConfigure('override', this.data.override, true);
      this.setConfigure('ignoreError', this.data.ignoreError, true);
      this.setConfigure('defaultRegistry', this.data.defaultRegistry, 'npm');
      this.setConfigure('flattenPackages', this.data.flattenPackages, true);
      this.setConfigure('flattenTypes', this.data.flattenTypes, false);
      this.setConfigure('flatten', this.data.flatten, false);
      this.setConfigure('types', this.data.types, _types2.default);
      this.setConfigure('renames', this.data.renames, {});
      this.setConfigure('replaces', this.data.replaces, {});
      this.setConfigure('processes', this.data.processes, {});
      this.setConfigure('dest', this.data.dest, 'assets');
      this.setConfigure('path', this.data.path, '${dest}/${type}/${package}/${file}');

      var cwd = this.data.cwd;
      if (cwd) {
        if (!_path2.default.isAbsolute(cwd)) {
          cwd = _path2.default.resolve(this.filepath === '.' ? '' : _path2.default.dirname(this.filepath), cwd);
        }
      }

      this.setConfigure('cwd', cwd, process.cwd());
    }
  }, {
    key: 'prepareRegistries',
    value: function prepareRegistries() {
      for (var key in this.data.registries) {
        _configure2.default.set('registry.' + key + '.dir', this.data.registries[key]);
      }
    }
  }, {
    key: 'preparePaths',
    value: function preparePaths() {
      this.paths = Object.assign({}, this.data.paths || {});

      Object.assign(this.paths, _util2.default.parseOptions(this.data, 'path'));
    }
  }, {
    key: 'prepareDests',
    value: function prepareDests() {
      this.dests = Object.assign({
        images: 'images',
        fonts: 'fonts',
        js: 'js',
        coffee: 'source/coffee',
        es6: 'source/es6',
        css: 'css',
        stylus: 'source/stylus',
        less: 'source/less',
        sass: 'source/sass',
        scss: 'source/scss'
      }, this.data.dests || {});

      Object.assign(this.dests, _util2.default.parseOptions(this.data, 'dest'));
    }
  }, {
    key: 'preparePackages',
    value: function preparePackages() {
      var packages = {};
      var installedPackages = {};

      for (var key in this.data.packages) {
        var _parsePackageKey = this.parsePackageKey(key);

        var name = _parsePackageKey.name;
        var registry = _parsePackageKey.registry;

        var _parsePackageConfig = this.parsePackageConfig(this.data.packages[key]);

        var defination = _parsePackageConfig.defination;
        var options = _parsePackageConfig.options;


        if (registry !== null) {
          options.registry = registry;
        }

        var pkg = new _Package2.default(name, defination, options);

        if (Object.hasOwnProperty.call(packages, name)) {
          if (Array.isArray(packages[name])) {
            packages[name].push(pkg);
          } else {
            packages[name] = [packages[name], pkg];
          }
        } else {
          packages[name] = pkg;
        }
        if (pkg.isInstalled()) {
          installedPackages[name] = pkg;
        }
      }

      this.packages = packages;
      this.installedPackages = installedPackages;
    }
  }, {
    key: 'parsePackageKey',
    value: function parsePackageKey(text) {
      var regex = /^([^:\s]+):([^:\s]+)$/;
      var match = regex.exec(text);

      if (match) {
        return {
          name: match[2],
          registry: match[1]
        };
      }

      return {
        name: text,
        registry: null
      };
    }
  }, {
    key: 'parsePackageConfig',
    value: function parsePackageConfig(config) {
      if (config === true) {
        return {
          defination: true,
          options: {}
        };
      }
      if (typeof config === 'string') {
        return {
          defination: config,
          options: {}
        };
      }
      if (Array.isArray(config)) {
        if (typeof config[0] !== 'string') {
          return {
            defination: config[0],
            options: config[1] || {}
          };
        }

        if (config[1] && (0, _isPlainObject2.default)(config[1])) {
          return {
            defination: config[0],
            options: config[1]
          };
        }

        return {
          defination: config,
          options: {}
        };
      }
      if ((0, _isPlainObject2.default)(config)) {
        return {
          defination: config,
          options: {}
        };
      }
    }
  }]);

  return Manifest;
}();

exports.default = Manifest;
module.exports = exports['default'];